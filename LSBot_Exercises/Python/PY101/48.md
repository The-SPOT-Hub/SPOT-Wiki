# PY101
## Problem 48: Plus vs Plus-Equals

```python
m = ["foo"]
n = ["bar"]
o = m
o = o + n
  
print(m, n, o)

# What will line 6 output and why?
  
m = ["foo"]
n = ["bar"]
o = m
o += n
  
print(m, n, o)

# Now, what will be output and why? 
# What's the difference?
```

**Bonus Questions:**
1. How many lists exist at the end of this code snippet? What are they?
2. Are there any method invocations in this code? Are methods the only way to mutate an object?
3. Does commenting out the first 6 lines have any effect on the last output, `print(m, n, o)`? Why or why not?

<details>
<summary>Solution:</summary>

First `print(m, n, o)` outputs: `['foo'] ['bar'] ['foo', 'bar']`

Second `print(m, n, o)` outputs: `['foo', 'bar'] ['bar'] ['foo', 'bar']`

**Explanation:**

In the first example, `o = o + n` creates a **new** list by concatenating `o` and `n`, then reassigns `o` to point to this new list. The original list that `m` points to remains unchanged.

In the second example, `o += n` **mutates** the list that `o` points to by extending it. Since `o` and `m` point to the same list, both variables reflect this change.

**Bonus Answers:**

**Bonus 1**: Three lists exist at the end:
- `['foo', 'bar']` (pointed to by both `m` and `o`)
- `['bar']` (pointed to by `n`)
- `['foo', 'bar']` (the list created in the first example, no longer referenced)

Actually, if we consider garbage collection, the unreferenced list from the first example may have been cleaned up, leaving only 2 lists.

**Bonus 2**: Yes, `+=` uses the `extend` method internally for lists. No, methods aren't the only way to mutate objectsâ€”operators like `+=` can also mutate objects (though `+` doesn't).

**Bonus 3**: No, commenting out the first 6 lines has no effect on the last output. Each section uses its own variables `m`, `n`, and `o`, and they're completely independent of each other.

</details>

---

[Previous](47.md) | [Next](49.md)

