# PY101
## Problem 95: Mutating Global Objects

Will this code throw an error? Why or why not? Do we need to use `global`?

```python
def alter_global():
    universal_list.pop()

universal_list = [1, 2, 3]
alter_global()
print(universal_list)
```

**Bonus Questions:**
1. How is it possible that we can alter `universal_list` before it's initialized on line 4? Is that what we're doing?
2. How does this problem change if we want to use a string, `'123'`, instead of a list?
3. What if we change the body of the function to `universal_list = universal_list[1:]`?

<details>
<summary>Solution:</summary>

This code does NOT throw an error. We do NOT need to use `global`.

Output: `[1, 2]`

**Explanation:**

We're **mutating** the global list object by calling `.pop()` on it. Mutation doesn't require the `global` keyword - we only need `global` when we want to **reassign** the variable (make it point to a different object).

Since we're just calling a method on the existing list object, Python can find `universal_list` in the global scope and mutate it directly.

**Bonus Answers:**

**Bonus 1**: We're not altering it before it's initialized! The function is *defined* before `universal_list` is initialized, but it's not *called* until after line 4. Python doesn't execute the function body until we actually call `alter_global()` on line 5, at which point `universal_list` already exists.

```python
# Function definition happens here (line 1-2)
def alter_global():
    universal_list.pop()  # This code doesn't run yet!

# Variable initialization happens here (line 4)
universal_list = [1, 2, 3]

# Function execution happens here (line 5)
alter_global()  # NOW the function body runs
```

**Bonus 2**: Strings are immutable, so we can't mutate them. Any string operation creates a new string:

```python
def alter_global():
    universal_string.replace('1', 'X')  # This doesn't actually change the string!

universal_string = '123'
alter_global()
print(universal_string)  # Still '123'
```

If we wanted to change the string, we'd need `global`:
```python
def alter_global():
    global universal_string
    universal_string = universal_string.replace('1', 'X')

universal_string = '123'
alter_global()
print(universal_string)  # 'X23'
```

**Bonus 3**: This would cause an `UnboundLocalError`:

```python
def alter_global():
    universal_list = universal_list[1:]  # UnboundLocalError!

universal_list = [1, 2, 3]
alter_global()
```

Because we're using assignment (`=`), Python treats `universal_list` as a local variable. But then we try to read it on the right side before it's been assigned, causing an error.

We'd need to use `global`:
```python
def alter_global():
    global universal_list
    universal_list = universal_list[1:]

universal_list = [1, 2, 3]
alter_global()
print(universal_list)  # [2, 3]
```

</details>

---

[Previous](094.md) | [Next](096.md)

