<p align="right">
  <a id="spot-launch-btn" class="spot-editor-link" href="https://launchschool.com/the-spot?url=https://github.com/The-SPOT-Hub/SPOT-Wiki/blob/main/LSBot_Exercises/Python/PY101/111.md" target="_blank">
  <img src="https://img.shields.io/badge/Work%20in%20LS%20Code%20Editor-555?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZyBmaWxsPSIjZjM1YjVhIj48cGF0aCBkPSJNOTgsMS45Yy0yLjUtMi41LTYuNi0yLjUtOS4xLDBMMjcuMiw2My43Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwTDk4LDExLjFDMTAwLjYsOC41LDEwMC41LDQuNSw5OCwxLjl6Ii8%2BPHBhdGggZD0iTTg4LjksNzQuOWwtMTQsMTRjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMTQtMTRjMi41LTIuNSwyLjUtNi42LDAtOS4xQzk1LjUsNzIuNCw5MS40LDcyLjQsODguOSw3NC45eiIvPjxwYXRoIGQ9Ik05OC4xLDM4LjRjLTIuNS0yLjUtNi42LTIuNS05LjEsMEw2Mi43LDY0LjZjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMjYuMy0yNi4zQzEwMC42LDQ1LDEwMC42LDQwLjksOTguMSwzOC40eiIvPjxwYXRoIGQ9Ik0yNSwyYy0yLjUtMi41LTYuNi0yLjUtOS4xLDBsLTE0LDE0Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwbDE0LTE0QzI3LjYsOC42LDI3LjYsNC41LDI1LDJ6Ii8%2BPHBhdGggZD0iTTM1LjQsMzcuM0w2MS42LDExYzIuNS0yLjUsMi41LTYuNiwwLTkuMWMtMi41LTIuNS02LjYtMi41LTkuMSwwTDI2LjIsMjguMmMtMi41LDIuNS0yLjUsNi42LDAsOS4xQzI4LjgsMzkuOCwzMi44LDM5LjgsMzUuNCwzNy4zeiIvPjwvZz48L3N2Zz4%3D" alt="Work in LS Code Editor">
</a>
</p>

# PY101
## Problem 111: Immutable Objects and Pass-by-Reference

Can a function that takes an integer as an argument ever exhibit pass-by-reference behavior? Why?

<details>
<summary>Solution:</summary>

No. Immutable objects passed into functions will *always* exhibit pass-by-value behavior because there's no way to alter the argument's value from within the function.

Since integers (and other immutable types like strings, tuples, and booleans) cannot be mutated, any operation creates a new object. Reassigning the parameter to this new object doesn't affect the original variable.

Examples:
```python
# Cannot modify an integer from within a function:
def try_to_modify(num):
    num = num + 10  # This creates a new integer
    print(f"Inside: {num}")

x = 5
try_to_modify(x)  # Inside: 15
print(x)  # 5 - unchanged
```

```python
# Same with strings:
def try_to_modify_string(s):
    s = s.upper()  # Creates a new string
    print(f"Inside: {s}")

text = "hello"
try_to_modify_string(text)  # Inside: HELLO
print(text)  # hello - unchanged
```

```python
# Even augmented assignment creates a new object:
def try_augmented_assignment(num):
    num += 5  # Equivalent to: num = num + 5
    return num

x = 10
result = try_augmented_assignment(x)
print(x)      # 10 - unchanged
print(result) # 15 - new value
```

**Why this matters:**
To "return" a modified value when working with immutable types, you must use return values and reassignment:

```python
def increment(num):
    return num + 1

x = 5
x = increment(x)  # Must reassign
print(x)  # 6
```

</details>

---

[Previous](110.md) | [Next](112.md)

