# PY101
## Problem 109: Nested Function Scope Access

What will be output when we run this code? What is being demonstrated by this snippet?

```python
def kaleidoscope():
    outer = 'Blue'
    def another():
        middle = 'Red'
        def another_again():
            inner = 'Green'
    
        another_again()
        print(outer)
        print(middle)
        print(inner)
    another()

kaleidoscope()
```

**Bonus Questions:**
1. How many scopes exist in this code, and where is each variable accessible?
2. Where could we move our `print` statements to be able to see all colors printed?
3. How could we change this code so that we see our colors printed *without* moving the `print` statements or eliminating nested functions?

<details>
<summary>Solution:</summary>

Output:
```
Blue
Red
NameError: name 'inner' is not defined
```

This demonstrates that variables defined outside of a function are accessible within that function, but variables defined within a function aren't available outside of that function.

The function `another` can access `outer` from `kaleidoscope` and its own `middle`, but it cannot access `inner` which is defined inside `another_again`.

**Bonus Answers:**

**Bonus 1**: Four scopes exist:

1. **Global scope**: No variables (empty in this example)
2. **`kaleidoscope` scope**: `outer` is accessible
3. **`another` scope**: `outer` and `middle` are accessible
4. **`another_again` scope**: `outer`, `middle`, and `inner` are all accessible

Variable accessibility:
- `outer` (defined in `kaleidoscope`): accessible in `kaleidoscope`, `another`, and `another_again`
- `middle` (defined in `another`): accessible in `another` and `another_again`
- `inner` (defined in `another_again`): accessible only in `another_again`

**Bonus 2**: The innermost scope of `another_again`:

```python
def kaleidoscope():
    outer = 'Blue'
    def another():
        middle = 'Red'
        def another_again():
            inner = 'Green'
            print(outer)   # All three are accessible here
            print(middle)
            print(inner)
    
        another_again()
    another()

kaleidoscope()
# Blue
# Red
# Green
```

**Bonus 3**: Use `nonlocal` to make `inner` accessible in the enclosing scope:

```python
def kaleidoscope():
    outer = 'Blue'
    def another():
        middle = 'Red'
        inner = None  # Declare in this scope
        
        def another_again():
            nonlocal inner  # Modify the one in another's scope
            inner = 'Green'
    
        another_again()
        print(outer)
        print(middle)
        print(inner)  # Now this works!
    another()

kaleidoscope()
# Blue
# Red
# Green
```

Or use `global` (though this is less appropriate):
```python
def kaleidoscope():
    outer = 'Blue'
    def another():
        middle = 'Red'
        def another_again():
            global inner  # Make it global
            inner = 'Green'
    
        another_again()
        print(outer)
        print(middle)
        print(inner)  # Accessible as global
    another()

kaleidoscope()
```

</details>

---

[Previous](108.md)

