<p align="right">
  <a id="spot-launch-btn" class="spot-editor-link" href="https://launchschool.com/the-spot?url=https://github.com/The-SPOT-Hub/SPOT-Wiki/blob/main/LSBot_Exercises/Python/PY101/118.md" target="_blank">
  <img src="https://img.shields.io/badge/Work%20in%20LS%20Code%20Editor-555?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZyBmaWxsPSIjZjM1YjVhIj48cGF0aCBkPSJNOTgsMS45Yy0yLjUtMi41LTYuNi0yLjUtOS4xLDBMMjcuMiw2My43Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwTDk4LDExLjFDMTAwLjYsOC41LDEwMC41LDQuNSw5OCwxLjl6Ii8%2BPHBhdGggZD0iTTg4LjksNzQuOWwtMTQsMTRjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMTQtMTRjMi41LTIuNSwyLjUtNi42LDAtOS4xQzk1LjUsNzIuNCw5MS40LDcyLjQsODguOSw3NC45eiIvPjxwYXRoIGQ9Ik05OC4xLDM4LjRjLTIuNS0yLjUtNi42LTIuNS05LjEsMEw2Mi43LDY0LjZjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMjYuMy0yNi4zQzEwMC42LDQ1LDEwMC42LDQwLjksOTguMSwzOC40eiIvPjxwYXRoIGQ9Ik0yNSwyYy0yLjUtMi41LTYuNi0yLjUtOS4xLDBsLTE0LDE0Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwbDE0LTE0QzI3LjYsOC42LDI3LjYsNC41LDI1LDJ6Ii8%2BPHBhdGggZD0iTTM1LjQsMzcuM0w2MS42LDExYzIuNS0yLjUsMi41LTYuNiwwLTkuMWMtMi41LTIuNS02LjYtMi41LTkuMSwwTDI2LjIsMjguMmMtMi41LDIuNS0yLjUsNi42LDAsOS4xQzI4LjgsMzkuOCwzMi44LDM5LjgsMzUuNCwzNy4zeiIvPjwvZz48L3N2Zz4%3D" alt="Work in LS Code Editor">
</a>
</p>

# PY101
## Problem 118: Destructive and Non-Destructive Filtering

Write two functions that transform a list of lists containing numbers. Both functions should return a list where the nested lists only contain even numbers.

- The first function should mutate the list passed as an argument but not the sublists.
- The second function should not mutate the list passed as an argument or the sublists.

```python
numbers1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
destructive_even_numbers(numbers1)
print(numbers1)  # Output: [[2], [4, 6], [8]]

numbers2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nondestructive_even_numbers(numbers2))  # Output: [[2], [4, 6], [8]]
print(numbers2)  # Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

**Bonus Questions:**
1. Write some code to prove that your functions have the intended behavior.
2. What did you choose as the return value of your mutating function? Why? Can you think of some built-in Python methods that have similar behavior?
3. What are some reasons to choose one function over the other?

<details>
<summary>Solution:</summary>

```python
# Mutating function (destructive)
def destructive_even_numbers(numbers):
    for i in range(len(numbers)):
        numbers[i] = [num for num in numbers[i] if num % 2 == 0]
    return None  # Explicitly returning None as this is a mutating function

# Non-mutating function (non-destructive)
def nondestructive_even_numbers(numbers):
    return [[num for num in sublist if num % 2 == 0] for sublist in numbers]

# Example Usage
numbers1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
destructive_even_numbers(numbers1)
print(numbers1)  # Output: [[2], [4, 6], [8]]

numbers2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nondestructive_even_numbers(numbers2))  # Output: [[2], [4, 6], [8]]
print(numbers2)  # Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

**Bonus Answers:**

**Bonus 1**: Prove the behavior using `is` or `id()`:

```python
# Test destructive version
original = [[1, 2, 3], [4, 5, 6]]
original_id = id(original)
original_sublist_ids = [id(sublist) for sublist in original]

destructive_even_numbers(original)

print(id(original) == original_id)  # True - same list object
print([id(sublist) for sublist in original])  # Different ids - new sublists
print(original)  # [[2], [4, 6]] - modified

# Test non-destructive version
original2 = [[1, 2, 3], [4, 5, 6]]
original2_id = id(original2)

result = nondestructive_even_numbers(original2)

print(id(result) == original2_id)  # False - different list
print(result is original2)  # False
print(original2)  # [[1, 2, 3], [4, 5, 6]] - unchanged
print(result)  # [[2], [4, 6]] - new list
```

**Bonus 2**: 

`None` is best for the mutating version. This follows Python conventions where functions that mutate in place typically return `None`:

Built-in methods with similar behavior:
- `list.sort()` - sorts in place, returns `None`
- `list.reverse()` - reverses in place, returns `None`
- `list.append()` - modifies list, returns `None`
- `dict.update()` - modifies dict, returns `None`

```python
my_list = [3, 1, 2]
result = my_list.sort()
print(result)    # None
print(my_list)   # [1, 2, 3]
```

This convention helps prevent confusion - if a method returns `None`, you know it probably mutated the object.

**Bonus 3**: When to choose each:

**Choose destructive (mutating):**
- Working with very large data structures (save memory)
- Caller expects the original to be modified
- Processing data in a pipeline where intermediate states don't matter
- Performance is critical (avoid copying)

```python
# Good use case for mutation:
huge_dataset = [[...], [...], ...]  # Millions of elements
destructive_even_numbers(huge_dataset)  # Modify in place
```

**Choose non-destructive:**
- Need to preserve original data
- Multiple parts of code use the same data
- Writing pure functions (no side effects)
- Easier to test and debug
- Concurrent/parallel processing

```python
# Good use case for non-destructive:
user_data = [[1, 2, 3], [4, 5, 6]]
display_data = nondestructive_even_numbers(user_data)
# Can still use user_data elsewhere unchanged
```

**General guideline:** Prefer non-destructive unless you have a specific reason to mutate.

</details>

---

[Previous](117.md) | [Next](119.md)

