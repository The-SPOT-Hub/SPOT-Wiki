# PY101
## Problem 116: Square Function Without Global

Given this expected behavior shown in this snippet, is it possible to write a `square_it` function that fulfills these requirements without using `global`? Why or why not?

```python
my_number = 2

square_it(my_number)
square_it(my_number)
square_it(my_number)

print(my_number)  # => 256
```

**Bonus Questions:**
1. What are two different alternatives you could propose to give similar behavior, but must be invoked differently?
2. Write the functions to go along with each of these proposed solutions and show the updated invocations to explain how you would need to use them.

<details>
<summary>Solution:</summary>

No. Integers are immutable. There's nothing we can do to the argument `my_number` from within a function that will alter its value outside of the function.

**Explanation:**

Since integers can't be mutated, any operation creates a new integer object. Without `global`, reassigning the parameter inside the function only affects the local variable, not the original.

```python
# This won't work:
def square_it(num):
    num = num * num  # Creates new integer, doesn't affect original

my_number = 2
square_it(my_number)
print(my_number)  # Still 2
```

**Bonus Answers:**

**Bonus 1**: Two alternatives:
1. Return the squared number and reassign it each time
2. Use a mutable data structure (like a list or dict) to hold the number

**Bonus 2**:

**Option 1: Return and reassign**
```python
my_number = 2

def square_it(num):
    return num * num

my_number = square_it(my_number)  # 4
my_number = square_it(my_number)  # 16
my_number = square_it(my_number)  # 256

print(my_number)  # => 256
```

**Option 2: Use a mutable container**
```python
my_number = [2]  # Use a list

def square_it(num_list):
    num_list[0] = num_list[0] * num_list[0]

square_it(my_number)  # [4]
square_it(my_number)  # [16]
square_it(my_number)  # [256]

print(my_number[0])  # => 256
```

Or with a dictionary:
```python
my_number = {'value': 2}

def square_it(num_dict):
    num_dict['value'] = num_dict['value'] ** 2

square_it(my_number)
square_it(my_number)
square_it(my_number)

print(my_number['value'])  # => 256
```

**Which is better?**

Option 1 (return and reassign) is more Pythonic and clearer. Option 2 works but is unnecessarily complex for this use case. Mutable containers should be used when you actually need to share state, not just to work around immutability.

</details>

---

[Previous](115.md) | [Next](117.md)

