# PY120
## Problem 11: Polymorphism

What is output and why? How does this code demonstrate polymorphism?

```python
class Animal:
    def eat(self):
        print("I eat.")

class Fish(Animal):
    def eat(self):
        print("I eat plankton.")

class Dog(Animal):
    def eat(self):
        print("I eat kibble.")

def feed_animal(animal):
    animal.eat()

array_of_animals = [Animal(), Fish(), Dog()]
for animal in array_of_animals:
    feed_animal(animal)
```

<details>
<summary>Solution:</summary>

The output is:
```
I eat.
I eat plankton.
I eat kibble.
```

This code demonstrates **polymorphism** - the ability of different objects to respond to the same method call in different ways.

Here's how it works:

1. All three classes (`Animal`, `Fish`, `Dog`) implement an `eat()` method
2. The `feed_animal()` function accepts any object and calls its `eat()` method without needing to know the specific type
3. Each object responds to `eat()` with its own implementation

This is polymorphism through inheritance and method overriding:
- `Fish` and `Dog` inherit from `Animal` but override the `eat()` method with their own specific implementations
- The `feed_animal()` function can work with any object that has an `eat()` method, regardless of the object's specific class
- The correct `eat()` method is called based on the actual type of the object at runtime (dynamic dispatch)

This demonstrates one of the key benefits of polymorphism: we can write generic code (`feed_animal()`) that works with different types of objects without needing to check their specific type.

</details>

---

[Previous](10.md) | [Next](12.md)
