# PY130 - Closures, Decorators & Partial Functions
## Problem 103: Class-Based Decorators

Decorators can also be implemented as classes. Create a class-based decorator called `CallCounter` that counts how many times a function has been called.

## Examples:

```python
@CallCounter
def greet(name):
    return f"Hello, {name}!"

greet("Alice")
greet("Bob")
greet("Charlie")

print(greet.count)  # 3
```
<details>
<summary>Solution:</summary>


```python
class CallCounter:
    def __init__(self, func):
        self.func = func
        self.count = 0
        
    def __call__(self, *args, **kwargs):
        self.count += 1
        return self.func(*args, **kwargs)

```

`def __init__(self, func):`

- When the decorator `@CallCounter` is applied to `greet`, Python creates an instance of `CallCounter` and passes the original greet function to its `__init__` method.
- `self.func = func` stores the original `greet` function in an instance attribute, so we can call it later.
- `self.count = 0` initializes an instance-specific counter. Each function decorated with `CallCounter` will get its own separate counter.

`def __call__(self, *args, **kwargs):`

- The `__call__` method makes the CallCounter instance itself callable. The name `greet` now refers to this instance.
- When you execute `greet("Alice")`, you are actually invoking this `__call__` method. The arguments ("Alice") are passed along via *args and **kwargs.
- `self.count += 1` increments the counter for this instance.
- `return self.func(*args, **kwargs)` executes the original `greet` function (stored in `self.func`) with the provided arguments and returns its result.

This structure ensures that the decorated function behaves exactly like the original, but with the added functionality of counting its calls.

</details>

---

[Previous](102.md) | [Next](104.md)
