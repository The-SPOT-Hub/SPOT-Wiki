# PY130
## Problem 18: Parameterized Repeat Decorator

Create a parameterized decorator named `repeat`. This decorator should accept an integer argument, `times`, and make the decorated function execute that many times. The decorator should also handle any arguments passed to the decorated function.

Demonstrate its use on a function `say_hello(name)` that prints a message like `"Hello, {name}"`. For example, `@repeat(3)` should cause the function to run three times.

<details>
<summary>Solution:</summary>

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            result = None
            for i in range(times):
                result = func(*args, **kwargs)
            return result  # Returns the result of the last execution
        return wrapper
    return decorator

# Apply to say_hello function
@repeat(3)
def say_hello(name):
    print(f"Hello, {name}!")

# Example usage:
say_hello("Alice")
```

**Output:**
```
Hello, Alice!
Hello, Alice!
Hello, Alice!
```

**Enhanced Version with Execution Counter:**

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                print(f"Execution {i + 1}/{times}:")
                result = func(*args, **kwargs)
                results.append(result)
            return results  # Returns list of all results
        return wrapper
    return decorator

@repeat(3)
def say_hello(name):
    print(f"Hello, {name}!")
    return f"Greeted {name}"

# Example usage:
results = say_hello("Bob")
print(f"Results: {results}")
```

**Output:**
```
Execution 1/3:
Hello, Bob!
Execution 2/3:
Hello, Bob!
Execution 3/3:
Hello, Bob!
Results: ['Greeted Bob', 'Greeted Bob', 'Greeted Bob']
```

**Version with Configurable Behavior:**

```python
def repeat(times, return_all=False, show_counter=False):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                if show_counter:
                    print(f"[{i + 1}/{times}]", end=" ")
                result = func(*args, **kwargs)
                results.append(result)
            
            return results if return_all else results[-1]
        return wrapper
    return decorator

@repeat(3, show_counter=True)
def countdown(n):
    print(f"T-minus {n}!")
    return n

@repeat(2, return_all=True)
def get_random_number():
    import random
    num = random.randint(1, 10)
    print(f"Generated: {num}")
    return num

# Example usage:
countdown(5)
print()
numbers = get_random_number()
print(f"All generated numbers: {numbers}")
```

**Practical Example - Retry Mechanism:**

```python
def retry(times, ignore_exceptions=False):
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(times):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if not ignore_exceptions or attempt == times - 1:
                        if attempt < times - 1:
                            print(f"Attempt {attempt + 1} failed: {e}. Retrying...")
                        else:
                            print(f"All {times} attempts failed.")
                            raise last_exception
            return None
        return wrapper
    return decorator

@retry(3, ignore_exceptions=True)
def unreliable_network_call():
    import random
    if random.random() < 0.7:  # 70% chance of failure
        raise ConnectionError("Network timeout")
    return "Success!"

# Example usage (may need multiple runs to see retry behavior):
# result = unreliable_network_call()
# print(result)
```

</details>

---

[Previous](17.md) | [Next](19.md)