# JS101
## Problem 96: Oddify Function

What happens when we execute the `oddify` function? Explain why.

```js
function oddify(nums) {
  nums.forEach((num, idx) => {
    if (num % 2 === 0) nums[idx] = num + 1;
  });

  return nums;
}

const nums = [1, 2, 5, 4, 12];
console.log(oddify(nums));
```

### Bonus Questions
1. What happens if our argument only includes odd numbers?
2. How many functions do we have in this code? How many of them exhibit PBR behaviour?
3. How would you refactor the function to eliminate side effects?

<details>
<summary>Solution:</summary>

**Output:** `[1, 3, 5, 5, 13]`

**Explanation:**

The function receives a reference to the array and mutates it by incrementing any even numbers to make them odd:
- `1` is odd → stays `1`
- `2` is even → becomes `3`
- `5` is odd → stays `5`
- `4` is even → becomes `5`
- `12` is even → becomes `13`

The function then returns the same array reference. This exhibits pass-by-reference behavior because the original `nums` array is mutated.

**Bonus Questions:**

1. The function will simply return the original array intact. It's still pass-by-reference, though - the function still receives a reference to the array, it just doesn't perform any mutations.

```js
const nums = [1, 3, 5, 7];
console.log(oddify(nums));  // [1, 3, 5, 7]
console.log(nums);          // [1, 3, 5, 7] (same array)
```

2. Three functions, all of which receive objects as arguments:
   - `oddify` - receives the array
   - The `forEach` callback - receives the array element (`num`) and index (`idx`), but more importantly...
   - **Note:** The callback also has access to the array through closure (`nums`), which it uses to perform mutations via `nums[idx]`

All three technically exhibit PBR behavior because they all have access to the array reference (whether as a parameter or through closure).

3. Example solution to eliminate side effects:

```js
function oddify(nums) {
  return nums.map(num => {
    if (num % 2 === 0) return num + 1;
    return num;
  });
}

const nums = [1, 2, 5, 4, 12];
const result = oddify(nums);
console.log(result);  // [1, 3, 5, 5, 13]
console.log(nums);    // [1, 2, 5, 4, 12] (unchanged)
```

This version uses `map` which returns a new array, leaving the original unchanged. It's a pure function with no side effects.

</details>

---

[Previous](095.md) | [Next](097.md)

