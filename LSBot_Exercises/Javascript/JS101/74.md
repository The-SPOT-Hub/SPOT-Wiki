# JS101
## Problem 74: Reassignment Without Parameters

Unlike the last problem, we *are* able to use reassignment within `squareNumber`. Why?

```js
function squareNumber() {
  number = number * number;
}

let number = 4;
squareNumber();
console.log(number); // 16
```

### Bonus Questions
1. This code works, however it's a bit misleading. What should we change?
2. How does this problem change if we add a `number` parameter to `squareNumber`?
3. How is it possible that we can access `number` on line 2 before it's initialized on line 5? Is that what we're doing?

<details>
<summary>Solution:</summary>

**Explanation:**

This works because `squareNumber` has no parameters and doesn't declare a local `number` variable. Therefore, when we reference `number` on line 2, JavaScript looks in the outer scope and finds the `number` variable declared on line 5. Since there's no `let`, `const`, or parameter shadowing it, the reassignment on line 2 modifies the outer `number`.

The key difference from Problem 73:
- Problem 73: Parameter `sentence` created a local variable that shadowed the outer one
- This problem: No parameter or local declaration, so `number` refers to the outer variable

**Bonus Questions:**

1. This code is misleading because it looks like the function is independent, but it actually depends on an outer variable. Better approaches:

```js
// Option 1: Use a parameter
function squareNumber(num) {
  return num * num;
}

let number = 4;
number = squareNumber(number);
console.log(number); // 16

// Option 2: Make the dependency explicit
function squareNumber() {
  return number * number;  // Use 'return' to make it clear we're using outer scope
}

let number = 4;
number = squareNumber();
console.log(number); // 16
```

2. If we add a `number` parameter:

```js
function squareNumber(number) {  // Parameter shadows outer variable
  number = number * number;       // Only modifies the parameter
}

let number = 4;
squareNumber(number);
console.log(number); // 4 (unchanged!)
```

Now the parameter creates a local `number` that shadows the outer one, so the reassignment only affects the local parameter, not the outer variable.

3. We're not accessing `number` "before" it's initialized in a temporal sense - we're accessing it from a different scope. When `squareNumber()` is called on line 6 (after `number` is initialized), the function executes and looks up `number` in the outer scope at that moment. JavaScript's lexical scoping means the function can access variables from its outer scope, regardless of where the function is defined relative to where the variable is declared (as long as the variable exists when the function is actually invoked).

</details>

---

[Previous](73.md)

