# JS101
## Problem 83: Nested Block Scoping Rules

Are the scoping rules for nested blocks any different from the scoping rules for non-nested blocks?

<details>
<summary>Solution:</summary>

No, the scoping rules are the same. Whether a block is nested or not, the fundamental rules remain consistent:

1. Variables declared in a block are scoped to that block
2. Inner scopes can access variables from outer scopes
3. Outer scopes cannot access variables from inner scopes
4. Variables can shadow outer variables with the same name

**Non-nested block:**

```js
let outer = 'outer';

{
  let block = 'block';
  console.log(outer);  // ✓ Can access outer
}

console.log(block);  // ✗ ReferenceError
```

**Nested blocks - same rules apply:**

```js
let outer = 'outer';

{
  let block1 = 'block1';
  
  {
    let block2 = 'block2';
    console.log(outer);   // ✓ Can access outer
    console.log(block1);  // ✓ Can access block1
  }
  
  console.log(block2);  // ✗ ReferenceError
}
```

**Shadowing works the same:**

```js
let name = 'outer';

{
  let name = 'block1';  // Shadows outer
  
  {
    let name = 'block2';  // Shadows block1's name
    console.log(name);    // 'block2'
  }
  
  console.log(name);  // 'block1'
}

console.log(name);  // 'outer'
```

The nesting just creates additional layers in the scope chain, but each layer follows the same rules. JavaScript always:
- Looks in the current scope first
- Walks outward through enclosing scopes
- Stops at the first matching variable name
- Throws ReferenceError if not found anywhere

</details>

---

[Previous](82.md) | [Next](84.md)

