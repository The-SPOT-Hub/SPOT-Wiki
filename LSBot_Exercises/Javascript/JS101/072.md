# JS101
## Problem 72: Function Scope and Shadowing

What's output when we run this code? Why?

```js
function myFunc() {
  foo = 'FOO';
  let bar = 'BAR';
}

let foo = 'foo';
let bar = 'bar';

myFunc();
console.log(foo);
console.log(bar);
```

### Bonus Questions
1. What happens when we declare a variable with `let`?
2. Can we access both `foo` and `bar` from within `myFunc`? If so, how come this code doesn't change the value of `bar`?
3. What's the difference between lines 2 and 3?

<details>
<summary>Solution:</summary>

**Output:**
```
FOO
bar
```

**Explanation:**

- Line 2: `foo = 'FOO'` (no `let`) reassigns the outer `foo` variable
- Line 3: `let bar = 'BAR'` creates a NEW local variable `bar` that shadows the outer `bar`
- When `myFunc()` is called:
  - `foo` is reassigned to `'FOO'` (affects outer variable)
  - A new local `bar` is created with value `'BAR'` (doesn't affect outer `bar`)
- After the function executes:
  - `foo` has been changed to `'FOO'`
  - `bar` is still `'bar'` (unchanged)

**Bonus Questions:**

1. A variable declaration is a statement that asks the JavaScript engine to reserve space for a variable with a particular name. Optionally, it also specifies an initial value for the variable. Using `let` (or `const`) creates a new variable in the current scope.

2. Yes, we can access both `foo` and `bar` from within `myFunc` if we don't shadow them. However, line 3 uses `let bar`, which creates a NEW local variable `bar` that shadows the outer one. So while we could access the outer `bar` (if we didn't declare a local one), the `let` declaration creates a shadow that hides the outer variable. Line 2 doesn't use `let`, so it just reassigns the existing outer `foo`.

3. Line 2 is reassignment (modifies existing variable). Line 3 is declaration and initialization (creates new variable). The presence of `let` makes all the difference.

</details>

---

[Previous](071.md) | [Next](073.md)

