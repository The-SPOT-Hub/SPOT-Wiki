# JS101
## Problem 97: Create People Bug

There's a problem with this code. Can you identify precisely what is causing the issue and propose a solution?

```js
function createPeople(names, ages) {
  let people = [];

  let defaultContainer = {};
  function createPerson(name, age, container = defaultContainer) {
    container.name = name;
    container.age = age;
    return container;
  }

  for (let i = 0; i < names.length; i += 1) {
    people.push(createPerson(names[i], ages[i]));
  }

  return people;
}

let names = ['Alice', 'Bob', 'Marcel', 'Juniper'];
let ages = [44, 25, 88, 4];
console.log(createPeople(names, ages));
```

### Bonus Questions
1. How does your proposed solution behave when we have a different length for our `names` array and `ages` array?
2. What if we wanted to mutate the `names` array to get the desired outcome?
3. Can you write a snippet that demonstrates a good use case for a default argument, to help whoever wrote this code understand how one can be used?

<details>
<summary>Solution:</summary>

**The Problem:**

The `defaultContainer` object is reused for every person. Since objects are passed by reference, all the people in the array end up referencing the same object. Each iteration mutates this shared object, so all array elements point to the same object with the last person's data.

**Output:**
```js
[
  { name: 'Juniper', age: 4 },
  { name: 'Juniper', age: 4 },
  { name: 'Juniper', age: 4 },
  { name: 'Juniper', age: 4 }
]
```

**The Solution:**

Create a new object for each person:

```js
function createPeople(names, ages) {
  let people = [];

  function createPerson(name, age) {
    return { name: name, age: age };  // Create new object each time
  }

  for (let i = 0; i < names.length; i += 1) {
    people.push(createPerson(names[i], ages[i]));
  }

  return people;
}

// Or more simply:
function createPeople(names, ages) {
  let people = [];
  
  for (let i = 0; i < names.length; i += 1) {
    people.push({ name: names[i], age: ages[i] });
  }

  return people;
}
```

**Bonus Questions:**

1. If the arrays have different lengths, the loop will iterate based on `names.length`. People with missing ages would get `undefined` for their age, and extra ages would be ignored:

```js
let names = ['Alice', 'Bob', 'Marcel'];
let ages = [44, 25];
// Result: [
//   { name: 'Alice', age: 44 },
//   { name: 'Bob', age: 25 },
//   { name: 'Marcel', age: undefined }
// ]
```

We could use `Math.min(names.length, ages.length)` to only create people when both values exist.

2. Mutating the `names` array:

```js
function createPeople(names, ages) {
  let people = [];
  
  for (let i = 0; i < names.length; i += 1) {
    people.push({
      name: names.shift(),  // Mutates names array
      age: ages[i]
    });
    i--;  // Adjust index since array shrinks
  }

  return people;
}

let names = ['Alice', 'Bob', 'Marcel', 'Juniper'];
let ages = [44, 25, 88, 4];
console.log(createPeople(names, ages));
console.log(names);  // [] (emptied)
```

Though this works, it's generally bad practice to mutate input arrays.

3. Good use case for default arguments:

```js
function greet(name, greeting = 'Hello') {
  console.log(`${greeting}, ${name}!`);
}

greet('Alice');           // "Hello, Alice!"
greet('Bob', 'Hi');       // "Hi, Bob!"
greet('Carol', 'Hey');    // "Hey, Carol!"
```

The key difference: default arguments should be **values** (primitives) or **newly created objects**, not shared object references. Each time you need an object default, create a new one:

```js
// GOOD: Creates new object each time
function process(data, options = {}) {
  // Each call gets its own options object
}

// BAD: Shares the same object
let sharedOptions = {};
function process(data, options = sharedOptions) {
  // All calls share the same options object - dangerous!
}
```

</details>

---

[Previous](96.md) | [Next](98.md)

