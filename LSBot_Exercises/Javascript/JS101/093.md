# JS101
## Problem 93: Pass-by-Reference Without Mutation

If a function behaves as pass-by-reference, will it always mutate its argument(s)?

<details>
<summary>Solution:</summary>

No. The function may receive a reference of an object but not mutate it.

Pass-by-reference means the function has access to the original object through a reference, but the function can choose whether or not to mutate it.

**Function receives reference but doesn't mutate:**

```js
function getLength(arr) {
  return arr.length;  // Reads property, doesn't mutate
}

let numbers = [1, 2, 3, 4];
let len = getLength(numbers);
console.log(len);      // 4
console.log(numbers);  // [1, 2, 3, 4] (unchanged)
```

**Another example:**

```js
function getFirstElement(arr) {
  return arr[0];  // Accesses element, doesn't mutate
}

let items = ['apple', 'banana', 'cherry'];
let first = getFirstElement(items);
console.log(first);  // 'apple'
console.log(items);  // ['apple', 'banana', 'cherry'] (unchanged)
```

**The function has the power to mutate, but may choose not to:**

```js
function processArray(arr) {
  // Could mutate with arr.push(5), arr[0] = 100, etc.
  // But instead, just returns new array
  return arr.map(x => x * 2);
}

let numbers = [1, 2, 3];
let doubled = processArray(numbers);
console.log(numbers);  // [1, 2, 3] (unchanged)
console.log(doubled);  // [2, 4, 6] (new array)
```

**Key takeaway:**

Pass-by-reference gives a function the *ability* to mutate the original object, but whether it actually does is up to the function's implementation. Well-designed functions often avoid mutations even when they could perform them, making code more predictable and easier to reason about.

</details>

---

[Previous](092.md) | [Next](094.md)

