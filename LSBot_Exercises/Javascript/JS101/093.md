<p align="right">
  <a id="spot-launch-btn" class="spot-editor-link" href="https://launchschool.com/the-spot?url=https://github.com/The-SPOT-Hub/SPOT-Wiki/blob/main/LSBot_Exercises/Javascript/JS101/093.md" target="_blank">
  <img src="https://img.shields.io/badge/Work%20in%20LS%20Code%20Editor-555?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZyBmaWxsPSIjZjM1YjVhIj48cGF0aCBkPSJNOTgsMS45Yy0yLjUtMi41LTYuNi0yLjUtOS4xLDBMMjcuMiw2My43Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwTDk4LDExLjFDMTAwLjYsOC41LDEwMC41LDQuNSw5OCwxLjl6Ii8%2BPHBhdGggZD0iTTg4LjksNzQuOWwtMTQsMTRjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMTQtMTRjMi41LTIuNSwyLjUtNi42LDAtOS4xQzk1LjUsNzIuNCw5MS40LDcyLjQsODguOSw3NC45eiIvPjxwYXRoIGQ9Ik05OC4xLDM4LjRjLTIuNS0yLjUtNi42LTIuNS05LjEsMEw2Mi43LDY0LjZjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMjYuMy0yNi4zQzEwMC42LDQ1LDEwMC42LDQwLjksOTguMSwzOC40eiIvPjxwYXRoIGQ9Ik0yNSwyYy0yLjUtMi41LTYuNi0yLjUtOS4xLDBsLTE0LDE0Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwbDE0LTE0QzI3LjYsOC42LDI3LjYsNC41LDI1LDJ6Ii8%2BPHBhdGggZD0iTTM1LjQsMzcuM0w2MS42LDExYzIuNS0yLjUsMi41LTYuNiwwLTkuMWMtMi41LTIuNS02LjYtMi41LTkuMSwwTDI2LjIsMjguMmMtMi41LDIuNS0yLjUsNi42LDAsOS4xQzI4LjgsMzkuOCwzMi44LDM5LjgsMzUuNCwzNy4zeiIvPjwvZz48L3N2Zz4%3D" alt="Work in LS Code Editor">
</a>
</p>

# JS101
## Problem 93: Pass-by-Reference Without Mutation

If a function behaves as pass-by-reference, will it always mutate its argument(s)?

<details>
<summary>Solution:</summary>

No. The function may receive a reference of an object but not mutate it.

Pass-by-reference means the function has access to the original object through a reference, but the function can choose whether or not to mutate it.

**Function receives reference but doesn't mutate:**

```js
function getLength(arr) {
  return arr.length;  // Reads property, doesn't mutate
}

let numbers = [1, 2, 3, 4];
let len = getLength(numbers);
console.log(len);      // 4
console.log(numbers);  // [1, 2, 3, 4] (unchanged)
```

**Another example:**

```js
function getFirstElement(arr) {
  return arr[0];  // Accesses element, doesn't mutate
}

let items = ['apple', 'banana', 'cherry'];
let first = getFirstElement(items);
console.log(first);  // 'apple'
console.log(items);  // ['apple', 'banana', 'cherry'] (unchanged)
```

**The function has the power to mutate, but may choose not to:**

```js
function processArray(arr) {
  // Could mutate with arr.push(5), arr[0] = 100, etc.
  // But instead, just returns new array
  return arr.map(x => x * 2);
}

let numbers = [1, 2, 3];
let doubled = processArray(numbers);
console.log(numbers);  // [1, 2, 3] (unchanged)
console.log(doubled);  // [2, 4, 6] (new array)
```

**Key takeaway:**

Pass-by-reference gives a function the *ability* to mutate the original object, but whether it actually does is up to the function's implementation. Well-designed functions often avoid mutations even when they could perform them, making code more predictable and easier to reason about.

</details>

---

[Previous](092.md) | [Next](094.md)

