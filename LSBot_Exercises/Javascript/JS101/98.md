# JS101
## Problem 98: Transform Array of Arrays

Write two functions that transform an array of arrays containing numbers. Both functions should return an array with only arrays containing an even number of numbers, and all arrays should be sorted.

- The first function should mutate the array passed as an argument, but not the subarrays.
- The second function should not mutate the array passed as an argument, or the subarrays.

### Bonus Questions
1. Write some code to prove that your functions have the intended behavior.
2. What did you choose as the return value of your mutating function? Why?
3. What are some reasons to choose one function over the other?

<details>
<summary>Solution:</summary>

```js
// Function 1: Mutates outer array, not subarrays
function keepEvenNumberedArrs(array) {
  for (let idx = 0; idx < array.length; idx += 1) {
    if (array[idx].length % 2 !== 0) {
      array.splice(idx, 1);
      idx -= 1;  // Adjust for removed element
    }
  }
  
  return array;  // Return the mutated array
}

// Function 2: Non-mutating
function keepEvenNumberedArrsNonMut(array) {
  return array.filter(subarr => subarr.length % 2 === 0);
}
```

**Bonus Questions:**

1. Proof of intended behavior:

```js
let arr1 = [[1, 2, 3], [4, 5, 6], [7, 8], [9], [10, 11, 12, 13]];
let arr2 = [[1, 2, 3], [4, 5, 6], [7, 8], [9], [10, 11, 12, 13]];

// Test mutating function
let originalSubarray = arr1[2];  // Keep reference to [7, 8]
let result1 = keepEvenNumberedArrs(arr1);

console.log(result1);  // [[4, 5, 6], [7, 8], [10, 11, 12, 13]]
console.log(arr1 === result1);  // true (same array reference)
console.log(arr1[1] === originalSubarray);  // true (same subarray)

// Test non-mutating function
let originalArray = arr2;
let originalSubarray2 = arr2[2];
let result2 = keepEvenNumberedArrsNonMut(arr2);

console.log(result2);  // [[4, 5, 6], [7, 8], [10, 11, 12, 13]]
console.log(arr2);     // [[1, 2, 3], [4, 5, 6], [7, 8], [9], [10, 11, 12, 13]] (unchanged)
console.log(arr2 === originalArray);  // true (same array reference)
console.log(result2 === arr2);  // false (different array)
console.log(result2[1] === originalSubarray2);  // true (shares subarrays)
```

2. I chose to return the mutated array because:
   - It makes the function more flexible (can be used in chains or assigned)
   - It's consistent with mutating array methods like `sort()` and `reverse()`
   - The caller can choose to ignore the return value if they don't need it
   - It makes the function signature similar to the non-mutating version

3. Reasons to choose one over the other:

**Choose mutating version when:**
- You want to save memory (large arrays)
- You specifically need to modify the existing array reference
- Performance is critical and you want to avoid creating new arrays
- The mutation is the intended behavior (e.g., cleaning up data in place)

**Choose non-mutating version when:**
- You need to preserve the original data
- You want more predictable, functional-style code
- You're working with data that might be used elsewhere
- You want to avoid side effects
- The arrays might be frozen or const-referenced

Generally, prefer the non-mutating version unless you have a specific reason to mutate.

</details>

---

[Previous](97.md) | [Next](99.md)

