# JS101
## Problem 56: Short-Circuit Function Calls

What will be the output of the following code? Why?

```js
function foo() {
  let phrase = "foo was called";
  return phrase;
}

function bar() {
  let phrase = "bar was called";
  console.log(phrase);
}

let result = foo() && bar();

if (result) console.log(result);
```

### Bonus Questions
1. What does `result` reference at the end of this snippet?
2. What happens if we change both functions to return `phrase` instead of just `foo`?
3. What could we do if we wanted `result` to reference a *boolean* to indicate whether both functions have truthy return values?

<details>
<summary>Solution:</summary>

**Output:**
```
bar was called
```

**Explanation:**
1. `foo()` is called and returns `"foo was called"` (truthy)
2. Since the left side of `&&` is truthy, evaluation continues to the right side
3. `bar()` is called, which logs `"bar was called"` and returns `undefined`
4. `result` is assigned the return value of `bar()`, which is `undefined`
5. The `if (result)` check fails because `undefined` is falsy
6. Only the console.log from inside `bar()` produces output

**Bonus Questions:**

1. `result` references `undefined` (the return value of `bar()`).

2. If `bar` also returns `phrase`:
```js
function bar() {
  let phrase = "bar was called";
  console.log(phrase);
  return phrase;
}
```
Then `result` would be `"bar was called"` (the last truthy value in the `&&` chain), and the final `if` would execute, logging `"bar was called"` again. Total output:
```
bar was called
bar was called
```

3. We could use double bang to convert the return values to booleans, or the `Boolean()` constructor:
```js
let result = !!(foo() && bar());
// or
let result = Boolean(foo() && bar());
// or
let result = Boolean(foo()) && Boolean(bar());
```

</details>

---

[Previous](055.md) | [Next](057.md)

