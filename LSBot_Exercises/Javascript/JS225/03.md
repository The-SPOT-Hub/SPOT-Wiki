# JS225
## Problem 3: Context Loss

The code below is intended to log "Hello, world!" after a 1-second delay. However, it logs undefined. Explain the problem and provide two distinct ways to fix it.

```javascript
const greeter = {
  message: 'Hello, world!',
  logMessage: function() {
    console.log(this.message);
  }
};

setTimeout(greeter.logMessage, 1000);
```

<details>
<summary>Solution:</summary>

**Problem:** This is a classic example of "context loss". When you pass `greeter.logMessage` as a callback to `setTimeout`, you are only passing the function itself, not the context of the greeter object. The `setTimeout` function invokes this callback as a regular function, so its execution context (`this`) becomes the global object (window), which does not have a `message` property.

**Fix 1: Using bind** - You can create a new function with `this` permanently bound to the greeter object.

```javascript
setTimeout(greeter.logMessage.bind(greeter), 1000);
```

**Fix 2: Using a Wrapper Function** - You can wrap the method call in another function. When the wrapper function executes, `greeter.logMessage()` is called as a method on greeter, preserving its context.

```javascript
setTimeout(() => greeter.logMessage(), 1000);
```

</details>

---

[Previous](02.md) | [Next](04.md)