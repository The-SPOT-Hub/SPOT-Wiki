<p align="right">
  <a id="spot-launch-btn" class="spot-editor-link" href="https://launchschool.com/the-spot?url=https://github.com/The-SPOT-Hub/SPOT-Wiki/blob/main/LSBot_Exercises/Javascript/LS250/07.md" target="_blank">
  <img src="https://img.shields.io/badge/Work%20in%20LS%20Code%20Editor-555?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZyBmaWxsPSIjZjM1YjVhIj48cGF0aCBkPSJNOTgsMS45Yy0yLjUtMi41LTYuNi0yLjUtOS4xLDBMMjcuMiw2My43Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwTDk4LDExLjFDMTAwLjYsOC41LDEwMC41LDQuNSw5OCwxLjl6Ii8%2BPHBhdGggZD0iTTg4LjksNzQuOWwtMTQsMTRjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMTQtMTRjMi41LTIuNSwyLjUtNi42LDAtOS4xQzk1LjUsNzIuNCw5MS40LDcyLjQsODguOSw3NC45eiIvPjxwYXRoIGQ9Ik05OC4xLDM4LjRjLTIuNS0yLjUtNi42LTIuNS05LjEsMEw2Mi43LDY0LjZjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMjYuMy0yNi4zQzEwMC42LDQ1LDEwMC42LDQwLjksOTguMSwzOC40eiIvPjxwYXRoIGQ9Ik0yNSwyYy0yLjUtMi41LTYuNi0yLjUtOS4xLDBsLTE0LDE0Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwbDE0LTE0QzI3LjYsOC42LDI3LjYsNC41LDI1LDJ6Ii8%2BPHBhdGggZD0iTTM1LjQsMzcuM0w2MS42LDExYzIuNS0yLjUsMi41LTYuNiwwLTkuMWMtMi41LTIuNS02LjYtMi41LTkuMSwwTDI2LjIsMjguMmMtMi41LDIuNS0yLjUsNi42LDAsOS4xQzI4LjgsMzkuOCwzMi44LDM5LjgsMzUuNCwzNy4zeiIvPjwvZz48L3N2Zz4%3D" alt="Work in LS Code Editor">
</a>
</p>

# LS250
## Problem 7: Magic Index

You are given a sorted array of distinct integers. Write a function that finds an index i such that `arr[i] === i`. This is often called a "magic index". If no such index exists, return -1. Strive for a solution with a time complexity better than O(N).

**Example:**
```javascript
findMagicIndex([-10, -5, 0, 3, 7]); // 3 (since arr[3] === 3)
findMagicIndex([0, 2, 5, 8, 17]);   // 0 (since arr[0] === 0)
findMagicIndex([-1, 0, 1, 2, 5]);   // -1 (no such index exists)
```

<details>
<summary>Solution:</summary>

```javascript
function findMagicIndex(arr) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === mid) {
      return mid;
    } else if (arr[mid] < mid) {
      // If arr[mid] < mid, magic index must be on the right
      // because values are distinct and increasing
      left = mid + 1;
    } else {
      // If arr[mid] > mid, magic index must be on the left
      right = mid - 1;
    }
  }
  
  return -1;
}
```

**Algorithm Explanation:**

1. **Binary search approach**: Use the sorted and distinct properties
2. **Compare `arr[mid]` with `mid`**:
   - If `arr[mid] === mid`: Found magic index
   - If `arr[mid] < mid`: Magic index must be on the right (since values are distinct and increasing)
   - If `arr[mid] > mid`: Magic index must be on the left
3. **Continue until found or search space exhausted**

**Time Complexity:** O(log n) - Binary search eliminates half the search space each iteration
**Space Complexity:** O(1) - Only using a few variables

**Key Insight:**
Since the array is sorted and contains distinct integers, we can use the relationship between `arr[mid]` and `mid` to determine which half to search next.

</details>

---

[Previous](06.md) | [Next](08.md)