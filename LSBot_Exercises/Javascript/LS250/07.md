# LS250
## Problem 7: Magic Index

You are given a sorted array of distinct integers. Write a function that finds an index i such that `arr[i] === i`. This is often called a "magic index". If no such index exists, return -1. Strive for a solution with a time complexity better than O(N).

**Example:**
```javascript
findMagicIndex([-10, -5, 0, 3, 7]); // 3 (since arr[3] === 3)
findMagicIndex([0, 2, 5, 8, 17]);   // 0 (since arr[0] === 0)
findMagicIndex([-1, 0, 1, 2, 5]);   // -1 (no such index exists)
```

<details>
<summary>Solution:</summary>

```javascript
function findMagicIndex(arr) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === mid) {
      return mid;
    } else if (arr[mid] < mid) {
      // If arr[mid] < mid, magic index must be on the right
      // because values are distinct and increasing
      left = mid + 1;
    } else {
      // If arr[mid] > mid, magic index must be on the left
      right = mid - 1;
    }
  }
  
  return -1;
}
```

**Algorithm Explanation:**

1. **Binary search approach**: Use the sorted and distinct properties
2. **Compare `arr[mid]` with `mid`**:
   - If `arr[mid] === mid`: Found magic index
   - If `arr[mid] < mid`: Magic index must be on the right (since values are distinct and increasing)
   - If `arr[mid] > mid`: Magic index must be on the left
3. **Continue until found or search space exhausted**

**Time Complexity:** O(log n) - Binary search eliminates half the search space each iteration
**Space Complexity:** O(1) - Only using a few variables

**Key Insight:**
Since the array is sorted and contains distinct integers, we can use the relationship between `arr[mid]` and `mid` to determine which half to search next.

</details>

---

[Previous](06.md) | [Next](08.md)