# LS250
## Problem 9: Valid Binary Search Tree

Given the root of a binary tree, determine if it is a valid Binary Search Tree (BST).

A valid BST is defined as follows:

1. The left subtree of a node contains only nodes with values less than the node's value
2. The right subtree of a node contains only nodes with values greater than the node's value
3. Both the left and right subtrees must also be binary search trees

Assume the following TreeNode class definition:

```javascript
class TreeNode {
  constructor(value = 0, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

// Example 1: Valid BST
let root1 = new TreeNode(2);
root1.left = new TreeNode(1);
root1.right = new TreeNode(3);

console.log(isValidBST(root1)); // true

// Example 2: Invalid BST
let root2 = new TreeNode(5);
root2.left = new TreeNode(1);
root2.right = new TreeNode(4);
root2.right.left = new TreeNode(3);
root2.right.right = new TreeNode(6);

console.log(isValidBST(root2)); // false
```

<details>
<summary>Solution:</summary>

```javascript
function isValidBST(root) {
  return validateBST(root, -Infinity, Infinity);
}

function validateBST(node, min, max) {
  // Base case: empty tree is valid
  if (node === null) {
    return true;
  }
  
  // Check if current node violates BST property
  if (node.value <= min || node.value >= max) {
    return false;
  }
  
  // Recursively check left and right subtrees
  return validateBST(node.left, min, node.value) && 
         validateBST(node.right, node.value, max);
}
```

**Algorithm Explanation:**

1. **Range-based validation**: Each node must be within a valid range (min, max)
2. **For each node**:
   - Check if current node's value is within the allowed range
   - Update ranges for children:
     - Left child: range is (min, current_node.value)
     - Right child: range is (current_node.value, max)
3. **Recursive validation**: Both subtrees must also be valid BSTs

**Key Insight:**
Instead of just checking parent-child relationships, we maintain the valid range for each node based on all its ancestors.

**Time Complexity:** O(n) - Visit each node once
**Space Complexity:** O(h) - Height of the tree (recursion stack)

**Example walkthrough:**
```
Tree:    2
        / \
       1   3

validateBST(2, -∞, +∞)
├─ validateBST(1, -∞, 2) ✓
└─ validateBST(3, 2, +∞) ✓
Result: true
```

</details>

---

[Previous](08.md) | [Next](10.md)