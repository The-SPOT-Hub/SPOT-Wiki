<p align="right">
  <a id="spot-launch-btn" class="spot-editor-link" href="https://launchschool.com/the-spot?url=https://github.com/The-SPOT-Hub/SPOT-Wiki/blob/main/LSBot_Exercises/Javascript/LS250/09.md" target="_blank">
  <img src="https://img.shields.io/badge/Work%20in%20LS%20Code%20Editor-555?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZyBmaWxsPSIjZjM1YjVhIj48cGF0aCBkPSJNOTgsMS45Yy0yLjUtMi41LTYuNi0yLjUtOS4xLDBMMjcuMiw2My43Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwTDk4LDExLjFDMTAwLjYsOC41LDEwMC41LDQuNSw5OCwxLjl6Ii8%2BPHBhdGggZD0iTTg4LjksNzQuOWwtMTQsMTRjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMTQtMTRjMi41LTIuNSwyLjUtNi42LDAtOS4xQzk1LjUsNzIuNCw5MS40LDcyLjQsODguOSw3NC45eiIvPjxwYXRoIGQ9Ik05OC4xLDM4LjRjLTIuNS0yLjUtNi42LTIuNS05LjEsMEw2Mi43LDY0LjZjLTIuNSwyLjUtMi41LDYuNiwwLDkuMWMyLjUsMi41LDYuNiwyLjUsOS4xLDBsMjYuMy0yNi4zQzEwMC42LDQ1LDEwMC42LDQwLjksOTguMSwzOC40eiIvPjxwYXRoIGQ9Ik0yNSwyYy0yLjUtMi41LTYuNi0yLjUtOS4xLDBsLTE0LDE0Yy0yLjUsMi41LTIuNSw2LjYsMCw5LjFjMi41LDIuNSw2LjYsMi41LDkuMSwwbDE0LTE0QzI3LjYsOC42LDI3LjYsNC41LDI1LDJ6Ii8%2BPHBhdGggZD0iTTM1LjQsMzcuM0w2MS42LDExYzIuNS0yLjUsMi41LTYuNiwwLTkuMWMtMi41LTIuNS02LjYtMi41LTkuMSwwTDI2LjIsMjguMmMtMi41LDIuNS0yLjUsNi42LDAsOS4xQzI4LjgsMzkuOCwzMi44LDM5LjgsMzUuNCwzNy4zeiIvPjwvZz48L3N2Zz4%3D" alt="Work in LS Code Editor">
</a>
</p>

# LS250
## Problem 9: Valid Binary Search Tree

Given the root of a binary tree, determine if it is a valid Binary Search Tree (BST).

A valid BST is defined as follows:

1. The left subtree of a node contains only nodes with values less than the node's value
2. The right subtree of a node contains only nodes with values greater than the node's value
3. Both the left and right subtrees must also be binary search trees

Assume the following TreeNode class definition:

```javascript
class TreeNode {
  constructor(value = 0, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

// Example 1: Valid BST
let root1 = new TreeNode(2);
root1.left = new TreeNode(1);
root1.right = new TreeNode(3);

console.log(isValidBST(root1)); // true

// Example 2: Invalid BST
let root2 = new TreeNode(5);
root2.left = new TreeNode(1);
root2.right = new TreeNode(4);
root2.right.left = new TreeNode(3);
root2.right.right = new TreeNode(6);

console.log(isValidBST(root2)); // false
```

<details>
<summary>Solution:</summary>

```javascript
function isValidBST(root) {
  return validateBST(root, -Infinity, Infinity);
}

function validateBST(node, min, max) {
  // Base case: empty tree is valid
  if (node === null) {
    return true;
  }
  
  // Check if current node violates BST property
  if (node.value <= min || node.value >= max) {
    return false;
  }
  
  // Recursively check left and right subtrees
  return validateBST(node.left, min, node.value) && 
         validateBST(node.right, node.value, max);
}
```

**Algorithm Explanation:**

1. **Range-based validation**: Each node must be within a valid range (min, max)
2. **For each node**:
   - Check if current node's value is within the allowed range
   - Update ranges for children:
     - Left child: range is (min, current_node.value)
     - Right child: range is (current_node.value, max)
3. **Recursive validation**: Both subtrees must also be valid BSTs

**Key Insight:**
Instead of just checking parent-child relationships, we maintain the valid range for each node based on all its ancestors.

**Time Complexity:** O(n) - Visit each node once
**Space Complexity:** O(h) - Height of the tree (recursion stack)

**Example walkthrough:**
```
Tree:    2
        / \
       1   3

validateBST(2, -∞, +∞)
├─ validateBST(1, -∞, 2) ✓
└─ validateBST(3, 2, +∞) ✓
Result: true
```

</details>

---

[Previous](08.md) | [Next](10.md)