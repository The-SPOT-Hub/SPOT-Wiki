# LS250
## Problem 8: Reverse Linked List

Write a function to reverse a singly linked list. You will be given the head of the list and should return the new head of the reversed list.

Assume the following ListNode class definition:

```javascript
class ListNode {
  constructor(value = 0, next = null) {
    this.value = value;
    this.next = next;
  }
}

// Helper to create a linked list from array
function arrayToList(arr) {
  let dummy = new ListNode();
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next;
}

// Helper to convert list to array (for easy checking)
function listToArray(head) {
  let arr = [];
  while (head) {
    arr.push(head.value);
    head = head.next;
  }
  return arr;
}

// Test cases
let head1 = arrayToList([1,2,3,4,5]);
console.log(listToArray(reverseList(head1))); // [5,4,3,2,1]

let head2 = arrayToList([1]);
console.log(listToArray(reverseList(head2))); // [1]

let head3 = null;
console.log(listToArray(reverseList(head3))); // []
```

<details>
<summary>Solution:</summary>

```javascript
function reverseList(head) {
  let prev = null;
  let current = head;
  
  while (current !== null) {
    let next = current.next;  // Store next node
    current.next = prev;      // Reverse the link
    prev = current;           // Move prev forward
    current = next;          // Move current forward
  }
  
  return prev;  // prev is now the new head
}
```

**Algorithm Explanation:**

1. **Three pointers approach**: `prev`, `current`, and `next`
2. **For each node**:
   - Store the next node before modifying links
   - Reverse the current node's next pointer to point to previous
   - Move all pointers forward
3. **Return the new head**: `prev` becomes the new head after processing all nodes

**Step-by-step example:**
```
Original: 1 -> 2 -> 3 -> 4 -> 5 -> null

Step 1: null <- 1    2 -> 3 -> 4 -> 5 -> null
Step 2: null <- 1 <- 2    3 -> 4 -> 5 -> null
Step 3: null <- 1 <- 2 <- 3    4 -> 5 -> null
Step 4: null <- 1 <- 2 <- 3 <- 4    5 -> null
Step 5: null <- 1 <- 2 <- 3 <- 4 <- 5

Result: 5 -> 4 -> 3 -> 2 -> 1 -> null
```

**Time Complexity:** O(n) - Visit each node once
**Space Complexity:** O(1) - Only using a few pointer variables

</details>

---

[Previous](07.md) | [Next](09.md)