# RB130
## Problem 2: Blocks vs Methods

What are the key differences between a block and a method in Ruby? Discuss how they are defined, how they are called, and how they handle arguments.

<details>
<summary>Solution:</summary>

The key differences lie in their definition, invocation, and scope.

- **Definition**:
  - **Methods** are defined with the `def` and `end` keywords and are given a name. They are first-class objects in Ruby.
  - **Blocks** are anonymous chunks of code defined with `do..end` or `{...}`. They are not objects on their own and must be attached to a method call.

- **Calling/Invocation**:
  - **Methods** are invoked directly by their name, e.g., `my_method(arg)`.
  - **Blocks** are executed only when the method they are attached to yields control to them using the `yield` keyword.

- **Arguments**:
  - **Methods** have a formal parameter list defined with their name, e.g., `def my_method(param1)`. They generally have strict rules about the number of arguments (arity).
  - **Blocks** receive arguments from the `yield` statement. Block parameters are defined between pipe characters, e.g., `{ |param1| ... }`. The rules for argument binding in blocks are more lenient than for methods.

**Example:**

```ruby
# Method definition and call
def say_hello(name)
  "Hello, #{name}!"
end

puts say_hello("Alice") # => "Hello, Alice!"

# A method that takes and yields to a block
def process_name(name)
  puts "Calling the block for #{name}..."
  result = yield(name)
  puts "The block returned: #{result}"
end

# Calling the method with a block attached
process_name("Bob") { |n| "The name in uppercase is #{n.upcase}" }
# Output:
# Calling the block for Bob...
# The block returned: The name in uppercase is BOB
```

</details>

---

[Previous](01.md) | [Next](03.md)