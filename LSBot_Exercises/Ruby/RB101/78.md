# RB101
## Problem 78: Say Hi Method

What is the output when we run this code? Walk through what happens.

```ruby
def say_hi
  puts 'Hello!'
end
  
greeting = say_hi
word = ''
  
if greeting
  word = 'Something'
elsif greeting == false
  word = 'Something else'
else
  word = greeting
end
  
p "Wow" if word
```

**Bonus Questions:**
1. Do we invoke `say_hi` every time we reference `greeting`? Why or why not?
2. What happens if we change `puts` within `say_hi` to `p`?
3. Is the `say_hi` method truthy? Why or why not?

<details>
<summary>Solution:</summary>

**Output:**
```
Hello!
"Wow"
```

**Walkthrough:**

1. `def say_hi` defines the method (no execution yet)
2. `greeting = say_hi` calls the method:
   - `puts 'Hello!'` outputs "Hello!"
   - `puts` returns `nil`
   - `greeting` is assigned `nil`
3. `word = ''` initializes word to an empty string
4. Check `if greeting`: `nil` is falsy, so this branch doesn't run
5. Check `elsif greeting == false`: `nil == false` is `false`, so this doesn't run
6. `else` runs: `word = greeting` assigns `nil` to `word`
7. `p "Wow" if word`: In Ruby, empty strings are **truthy**, but `word` is now `nil` (falsy)
8. Wait - actually `word` was initially `''`, but then reassigned to `nil` in the else branch
9. So `p "Wow" if word` checks if `nil` is truthy - it's not, so "Wow" doesn't print

**Actually, let me reconsider:**
- `word = ''` (empty string, which is truthy in Ruby)
- `else` branch runs: `word = greeting` (assigns `nil` to word)
- Final line: `word` is now `nil` (falsy), so "Wow" is NOT printed

**Correct output:**
```
Hello!
```

Only "Hello!" is printed (from the `puts` in `say_hi`). "Wow" is not printed because `word` ends up being `nil`.

**Bonus Answers:**

**Bonus 1**: No, we invoke `say_hi` only once on line 5. `greeting` references the **return value** of `say_hi`, which is `nil`. Every other reference to `greeting` just accesses this `nil` value.

```ruby
greeting = say_hi  # Invokes once here
# Later references to greeting just access the nil value
```

**Bonus 2**: If we change `puts` to `p`:

```ruby
def say_hi
  p 'Hello!'  # p returns the value it prints
end

greeting = say_hi
```

The output would be the same for the first line (`'Hello!'` is still displayed), but now `greeting` would reference `'Hello!'` (the string) instead of `nil`, because `p` returns its argument.

```ruby
if greeting  # Now greeting is "Hello!" (truthy)
  word = 'Something'  # This branch runs
end

p "Wow" if word  # word is "Something" (truthy), so "Wow" prints
```

New output:
```
'Hello!'
"Wow"
```

**Bonus 3**: Methods don't have truthiness. The `say_hi` method, when invoked, **returns** a falsy value (`nil`). You can't check if a method is truthy - you can only check if its return value is truthy.

```ruby
# Can't do this:
# if say_hi  # This invokes the method and checks the return value

# This is what actually happens:
if say_hi  # Calls say_hi, gets nil, checks if nil is truthy
  puts "won't run"
end
```

</details>

---

[Previous](77.md) | [Next](79.md)

