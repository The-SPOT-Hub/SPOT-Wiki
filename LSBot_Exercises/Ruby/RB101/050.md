# RB101
## Problem 50: String Interpolation and Concatenation

Can you write the code necessary to get the desired output shown on the last line? Write two distinct solutions and explain the tools each uses.

```ruby
make = 'Ford'
model = 'Ranger'
year = 1995

sentence = ???

puts sentence
# Look! It's a 1995 Ford Ranger!
```

**Bonus Questions:**
1. Is there a benefit to using one method over the other?
2. Is there any type coercion happening in this code?
3. If we change the values referenced by `make`, `model`, or `year` after `sentence` has been initialized, will the sentence be updated?

<details>
<summary>Solution:</summary>

**Solution 1: String interpolation**
```ruby
sentence = "Look! It's a #{year} #{make} #{model}!"
```

String interpolation uses `#{}` inside double quotes to embed expressions. Ruby automatically calls `.to_s` on the values.

**Solution 2: String concatenation**
```ruby
sentence = "Look! It's a " + year.to_s + " " + make + " " + model + "!"
```

String concatenation uses the `+` operator to join strings together. Must explicitly convert non-strings using `.to_s`.

**Bonus Answers:**

**Bonus 1**: String interpolation is generally preferred:
- More readable and concise
- Automatic type conversion
- Better performance (creates one string object)
- Works with any expression: `"Sum: #{a + b}"`

Concatenation advantages:
- More explicit about types
- Easier to see exactly what's being added

**Bonus 2**: Yes! Type coercion is happening:

With interpolation:
```ruby
"The year is #{year}"  # year (integer) is coerced to string automatically
```

With concatenation:
```ruby
"The year is " + year.to_s  # Explicit coercion with .to_s
# "The year is " + year  # => TypeError! Can't concatenate integer
```

**Bonus 3**: No, the sentence will not be updated. Strings are evaluated when created:

```ruby
make = 'Ford'
sentence = "Car: #{make}"
make = 'Toyota'
puts sentence  # => "Car: Ford" (not "Car: Toyota")
```

However, if `sentence` were a *method* instead of a variable, it could return updated values:
```ruby
make = 'Ford'
def sentence
  "Car: #{make}"
end

make = 'Toyota'
puts sentence  # Would need access to make variable (would cause error as written)
```

Better example with method:
```ruby
def sentence(make, model, year)
  "Look! It's a #{year} #{make} #{model}!"
end

make = 'Ford'
puts sentence(make, 'Ranger', 1995)  # Uses current value of make
```

</details>

---

[Previous](049.md) | [Next](051.md)

