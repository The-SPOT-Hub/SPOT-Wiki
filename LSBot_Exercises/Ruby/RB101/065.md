# RB101
## Problem 65: Library Management System

Given a `library` hash that holds "book" key/value pairs like so:

```ruby
library = {
  "Moby Dick" => { author: "Herman Melville", copies: 3 },
  "1984" => { author: "George Orwell", copies: 5 },
}
```

Write two methods, `checkout` and `checkin` that manage the books in the library. Refer to the test invocations to see the intended behavior:

```ruby
# Your definitions here

checkin(library, "Moby Dick")

puts library

# Expected output:
# {
#   "Moby Dick" => { author: "Herman Melville", copies: 4 },
#   "1984" => { author: "George Orwell", copies: 5 }
# }

checkout(library, "1984")

puts library

# Expected output:
# {
#   "Moby Dick" => { author: "Herman Melville", copies: 4 },
#   "1984" => { author: "George Orwell", copies: 4 }
# }
```

**Bonus Challenge:**

Make your methods sturdier by handling the situation in which someone tries to check in or check out a title that isn't present in the library. How did you choose to handle these situations and why?

<details>
<summary>Solution:</summary>

**Basic solution:**
```ruby
def checkin(library, book)
  library[book][:copies] += 1
end

def checkout(library, book)
  library[book][:copies] -= 1
end

# Test:
library = {
  "Moby Dick" => { author: "Herman Melville", copies: 3 },
  "1984" => { author: "George Orwell", copies: 5 },
}

checkin(library, "Moby Dick")
p library  # => {"Moby Dick"=>{:author=>"Herman Melville", :copies=>4}, "1984"=>{:author=>"George Orwell", :copies=>5}}

checkout(library, "1984")
p library  # => {"Moby Dick"=>{:author=>"Herman Melville", :copies=>4}, "1984"=>{:author=>"George Orwell", :copies=>4}}
```

**Bonus Challenge - Robust solution:**
```ruby
def checkin(library, book)
  if library.key?(book)
    library[book][:copies] += 1
  else
    puts "Error: '#{book}' is not in the library catalog."
  end
end

def checkout(library, book)
  if library.key?(book)
    if library[book][:copies] > 0
      library[book][:copies] -= 1
    else
      puts "Error: No copies of '#{book}' are currently available."
    end
  else
    puts "Error: '#{book}' is not in the library catalog."
  end
end

# Test with error handling:
library = {
  "Moby Dick" => { author: "Herman Melville", copies: 0 },
  "1984" => { author: "George Orwell", copies: 5 },
}

checkout(library, "Moby Dick")
# => Error: No copies of 'Moby Dick' are currently available.

checkout(library, "The Great Gatsby")
# => Error: 'The Great Gatsby' is not in the library catalog.

checkin(library, "The Great Gatsby")
# => Error: 'The Great Gatsby' is not in the library catalog.
```

**Alternative with return values:**
```ruby
def checkin(library, book)
  return false unless library.key?(book)
  library[book][:copies] += 1
  true
end

def checkout(library, book)
  return false unless library.key?(book)
  return false if library[book][:copies] == 0
  library[book][:copies] -= 1
  true
end

# Use return values:
success = checkout(library, "1984")
if success
  puts "Checked out successfully!"
else
  puts "Checkout failed."
end
```

**Design decisions:**

1. **Printing error messages**: Good for immediate user feedback, but makes testing harder
2. **Returning boolean**: Better for programmatic use, allows caller to decide how to handle errors
3. **Raising exceptions**: More Ruby-idiomatic for error conditions

```ruby
def checkout(library, book)
  raise "Book not found" unless library.key?(book)
  raise "No copies available" if library[book][:copies] == 0
  library[book][:copies] -= 1
end
```

**Why working with nested collections matters:**
```ruby
# We're accessing nested data:
library[book]         # Accesses the hash at this key
library[book][:copies]  # Accesses the value at :copies in that nested hash
library[book][:copies] += 1  # Mutates the nested hash
```

</details>

---

[Previous](064.md) | [Next](066.md)

