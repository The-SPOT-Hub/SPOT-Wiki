# RB101
## Problem 62: String Concatenation - += vs <<

```ruby
m = "foo"
n = "bar"
o = m
o += n
  
p m, n, o

# What will line 6 output and why?
  
m = "foo"
n = "bar"
o = m
o << n
  
p m, n, o

# Now, what will be output and why? 
# What's the difference?
```

**Bonus Questions:**
1. How many strings exist at the end of this code snippet? What are they?
2. Are there any method invocations in this code? If so, what are the callers, and what are the arguments?
3. Does commenting out the first 6 lines have any effect on the last output, `p m, n, o`? Why or why not?

<details>
<summary>Solution:</summary>

**First `p m, n, o` outputs:**
```
"foo"
"bar"
"foobar"
```

**Second `p m, n, o` outputs:**
```
"foobar"
"bar"
"foobar"
```

**Explanation:**

**First example (`o += n`):**
- `o += n` is equivalent to `o = o + n`
- This creates a **new** string by concatenating `o` and `n`, then reassigns `o` to point to this new string
- The original string that `m` points to remains unchanged
- So `m` is still `"foo"`, `n` is `"bar"`, and `o` is the new `"foobar"`

**Second example (`o << n`):**
- `o << n` **mutates** the string that `o` points to by appending `n`
- Since `o` and `m` point to the same string object, the change is visible through both variables
- So both `m` and `o` show `"foobar"`, while `n` is still `"bar"`

**Bonus Answers:**

**Bonus 1**: Three strings exist at the end:
1. `"foobar"` (pointed to by both `m` and `o`)
2. `"bar"` (pointed to by `n`)
3. `"foobar"` (the string created in the first example, no longer referenced)

Actually, if we consider garbage collection, the unreferenced `"foobar"` from the first example and the original `"foo"` may have been cleaned up, leaving just 2 strings.

**Bonus 2**: Yes, there are method invocations:

```ruby
# In `o << n`:
# Caller: the string object that o points to ("foo")
# Method: << (shovel operator)
# Argument: n (the string "bar")
o.<<(n)  # This is what << actually does

# `p` is also a method:
# Caller: Kernel (or main object)
# Method: p
# Arguments: m, n, o
```

The `+` operator in `o + n` is also a method call:
```ruby
o.+(n)  # This is what + actually does
```

**Bonus 3**: No, commenting out the first 6 lines has no effect on the last output. Each section uses its own variables `m`, `n`, and `o`. They're completely independent because the variables are reinitialized in the second section:

```ruby
# First section has its own m, n, o
m = "foo"
n = "bar"
o = m

# Second section creates new m, n, o
m = "foo"  # New variable, happens to have same name
n = "bar"
o = m
```

</details>

---

[Previous](61.md) | [Next](63.md)

