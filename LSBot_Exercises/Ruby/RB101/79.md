# RB101
## Problem 79: Chocolate Bar Shop Logic

Your friend shows you this code they've written to open up a chocolate bar shop. How can you demonstrate to them the logical flaw with this setup? Can you propose an alternative?

```ruby
my_cash = 10

if my_cash
  puts "One chocolate bar, please!"
else
  puts "I don't have 3 dollars to spend. :("
end
```

**Bonus Questions:**
1. Turn this into a method, `buy_chocolate_bar(cash)`.
2. Once you have a method, try to subtract the 3 dollars from the customer's cash. Do you run into any issues? Why?
3. Can you add an inventory that checks to make sure there are chocolate bars left before selling them?

<details>
<summary>Solution:</summary>

**The Flaw:**

This code can buy a chocolate bar even with `0` dollars or a negative amount, since these are truthy values in Ruby. In Ruby, only `nil` and `false` are falsy - `0` is truthy!

**Demonstration:**
```ruby
my_cash = 0
if my_cash
  puts "One chocolate bar, please!"  # This runs! 0 is truthy
end

my_cash = -100
if my_cash
  puts "One chocolate bar, please!"  # This also runs!
end
```

**Alternative:**
```ruby
my_cash = 10

if my_cash >= 3
  puts "One chocolate bar, please!"
else
  puts "I don't have 3 dollars to spend. :("
end
```

**Bonus Answers:**

**Bonus 1**: Turn it into a method:

```ruby
def buy_chocolate_bar(cash)
  if cash >= 3
    puts "One chocolate bar, please!"
    cash - 3  # Return remaining cash
  else
    puts "I don't have 3 dollars to spend. :("
    cash  # Return original cash
  end
end

remaining = buy_chocolate_bar(10)
p remaining  # => 7
```

**Bonus 2**: Issues with subtracting from the customer's cash:

```ruby
def buy_chocolate_bar(cash)
  if cash >= 3
    puts "One chocolate bar, please!"
    cash -= 3  # This only modifies the local parameter
  else
    puts "I don't have 3 dollars to spend. :("
  end
end

my_cash = 10
buy_chocolate_bar(my_cash)
p my_cash  # => 10 (unchanged!)
```

The problem is that integers are **immutable**. The `cash` parameter is a local variable that points to the integer. When we do `cash -= 3`, we're reassigning the local variable to a new integer, but this doesn't affect `my_cash` outside the method.

**Solution:** Return the new value and reassign:
```ruby
my_cash = 10
my_cash = buy_chocolate_bar(my_cash)
p my_cash  # => 7
```

**Bonus 3**: Add inventory:

```ruby
$inventory = 10  # Using global variable for simplicity

def buy_chocolate_bar(cash)
  if $inventory <= 0
    puts "Sorry, we're out of chocolate bars!"
    return cash
  end
  
  if cash >= 3
    puts "One chocolate bar, please!"
    $inventory -= 1
    cash - 3
  else
    puts "I don't have 3 dollars to spend. :("
    cash
  end
end

my_cash = 10
my_cash = buy_chocolate_bar(my_cash)
p "Remaining cash: #{my_cash}"
p "Inventory: #{$inventory}"
```

Better approach using a hash or class to manage state:
```ruby
def buy_chocolate_bar(cash, shop)
  if shop[:inventory] <= 0
    puts "Sorry, we're out!"
    return cash
  end
  
  if cash >= 3
    puts "One chocolate bar, please!"
    shop[:inventory] -= 1
    cash - 3
  else
    puts "I don't have 3 dollars to spend. :("
    cash
  end
end

shop = { inventory: 10 }
cash = 10
cash = buy_chocolate_bar(cash, shop)
p cash  # => 7
p shop  # => {:inventory=>9}
```

</details>

---

[Previous](78.md) | [Next](80.md)

