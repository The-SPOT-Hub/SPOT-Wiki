# RB101
## Problem 110: Method Parameters and Immutability

Your friend shows you this code and asks why they aren't getting the expected output. Explain what we get instead and why.

```ruby
def square_number(number)
  number = number * number
end

number = 4
square_number(number)
p number  # Expected: 16
```

**Bonus Questions:**
1. Precisely what options do we have for fixing this code to get the expected output?
2. Do we gain any more options if we change the data type of `number`? For example, what if we initialize `number` to `[4]`?
3. Why doesn't reassigning `number` within `square_number` change its value?

<details>
<summary>Solution:</summary>

**What we get:** `4` (not 16)

**Why:**

Integers are immutable in Ruby. When we do `number = number * number` inside the method:
1. It creates a new integer (16)
2. It reassigns the local parameter `number` to point to this new integer
3. This reassignment only affects the local variable in the method
4. The outer `number` variable is unchanged

The method doesn't (and can't) modify the outer `number` variable because:
- Methods can't access outer local variables
- The parameter `number` is a different variable from the outer `number`
- Reassignment only changes what the local variable points to

**Bonus Answers:**

**Bonus 1**: Options for fixing the code:

**Option 1: Use the return value**
```ruby
def square_number(number)
  number * number
end

number = 4
number = square_number(number)  # Reassign with return value
p number  # => 16
```

**Option 2: Use a global variable (not recommended)**
```ruby
def square_number
  $number = $number * $number
end

$number = 4
square_number
p $number  # => 16
```

**Option 3: Use an instance variable (in a class context)**
```ruby
class Calculator
  def initialize(number)
    @number = number
  end
  
  def square_number
    @number = @number * @number
  end
  
  def number
    @number
  end
end

calc = Calculator.new(4)
calc.square_number
p calc.number  # => 16
```

**Bonus 2**: Yes! If we use a mutable data structure:

```ruby
def square_number(number_arr)
  number_arr[0] = number_arr[0] * number_arr[0]
end

number = [4]  # Use an array
square_number(number)
p number  # => [16] (the array was mutated!)
```

This works because:
- Arrays are mutable
- We're not reassigning the array parameter, we're mutating the array itself
- The mutation affects the original object

**Bonus 3**: Why reassignment doesn't change the outer value:

The parameter `number` and the outer `number` are **two different variables** that initially point to the same object:

```ruby
number = 4  # Outer variable

def square_number(number)  # Parameter is a new variable
  puts number.object_id  # Same object ID initially
  number = number * number  # Creates new integer, reassigns parameter
  puts number.object_id  # Different object ID now
end

puts number.object_id  # Original object ID
square_number(number)
puts number.object_id  # Still original (unchanged)
```

The reassignment `number = number * number` only changes what the **local** `number` parameter points to. It doesn't affect the outer `number` variable at all.

**Visualization:**
```
Before method call:
  outer 'number' → 4
  
During method call:
  outer 'number' → 4
  parameter 'number' → 4 (same object)
  
After 'number = number * number':
  outer 'number' → 4 (unchanged)
  parameter 'number' → 16 (new object)
  
After method returns:
  outer 'number' → 4 (unchanged)
```

</details>

---

[Previous](109.md)

