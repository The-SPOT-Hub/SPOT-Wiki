# RB101
## Problem 91: Complex Ternary with Short-Circuiting

What will be the output of the following code? Explain the steps taken.

```ruby
def foo
  puts "foo was called"
  false
end

def bar
  puts "bar was called"
  true
end

result = foo ? bar : foo || bar ? foo : bar
```

**Bonus Questions:**
1. How does our answer change if we replace the `||` with `&&`?
2. What does `result` reference at the end of this snippet?
3. Do you think the expression on line 11 would be more readable with parentheses? If so, where?

<details>
<summary>Solution:</summary>

**Output:**
```
foo was called
foo was called
bar was called
```

**Step-by-step explanation:**

Let's break down: `foo ? bar : foo || bar ? foo : bar`

Due to precedence, this is evaluated as:
`foo ? bar : (foo || bar ? foo : bar)`

Steps:
1. Evaluate `foo` (for first ternary condition):
   - Prints "foo was called"
   - Returns `false`
2. Since `foo` returns `false`, evaluate the false branch: `foo || bar ? foo : bar`
3. This has another ternary, so evaluate its condition: `foo || bar`
4. Evaluate `foo` again:
   - Prints "foo was called"  
   - Returns `false`
5. Since `foo` is `false`, evaluate second operand of `||`: `bar`
6. Evaluate `bar`:
   - Prints "bar was called"
   - Returns `true`
7. `foo || bar` returns `true` (from `bar`)
8. Since the condition is `true`, evaluate the true branch: `foo`
9. But wait - we don't actually call `foo` again because we're in the false branch of the outer ternary, evaluating `foo || bar ? foo : bar` as a whole expression

Let me reconsider with proper precedence...

Actually: `foo || bar ? foo : bar` groups as `(foo || bar) ? foo : bar`

So:
1. `foo` called → prints "foo was called", returns `false`
2. Outer ternary's false branch: `(foo || bar) ? foo : bar`
3. Evaluate condition `foo || bar`:
   - `foo` called → prints "foo was called", returns `false`
   - `bar` called → prints "bar was called", returns `true`
4. Condition is `true`, so result is `foo` (but not called, just returned)
5. `result` gets `false` (the return value of the already-called `foo`)

Wait, I need to be more careful. Let me trace through again:

The expression is: `foo ? bar : foo || bar ? foo : bar`

Ternary has very low precedence, so this is: `foo ? bar : ((foo || bar) ? foo : bar)`

1. Evaluate first `foo`: prints "foo was called", returns `false`
2. Condition is false, so evaluate: `(foo || bar) ? foo : bar`
3. Evaluate `foo` (second call): prints "foo was called", returns `false`
4. Evaluate `bar`: prints "bar was called", returns `true`
5. `foo || bar` is `true`
6. Return `foo` (third call): prints "foo was called", returns `false`

Actually, step 6 should call `foo` again.

**Correct output:**
```
foo was called
foo was called
bar was called
foo was called
```

And `result` is `false`.

**Bonus Answers:**

**Bonus 1**: If we replace `||` with `&&`:

`foo ? bar : foo && bar ? foo : bar`
→ `foo ? bar : ((foo && bar) ? foo : bar)`

1. `foo` called: false
2. False branch: `(foo && bar) ? foo : bar`
3. `foo` called: false
4. `foo && bar` short-circuits, returns `false`
5. Condition is false, so return `bar` (call it): prints "bar was called", returns `true`

Output:
```
foo was called
foo was called
bar was called
```

`result` is `true`.

**Bonus 2**: At the end of the original snippet, `result` references `false` (the return value of the last `foo` call).

**Bonus 3**: Yes! The expression would be much more readable with parentheses:

```ruby
result = foo ? bar : ((foo || bar) ? foo : bar)

# Or even clearer:
condition1 = foo
condition2 = foo || bar
result = condition1 ? bar : (condition2 ? foo : bar)
```

This complex nesting is generally a code smell and should be refactored for clarity.

</details>

---

[Previous](090.md) | [Next](092.md)

